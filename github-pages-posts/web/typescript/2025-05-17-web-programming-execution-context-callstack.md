---
layout: single
title: "[web/typescript] 실행컨텍스트와 콜스택"
categories: web/typescript
---

#### 핵심요약

> - js 코드에는 4가지 타입이 있고, 전역 코드와 함수 코드를 주로 사용함.
> - 실행컨텍스트 : 각 코드에 대한 환경(각 코드 내 현재 변수 상태등)을 다루는 객체
> - js는 코드 실행시, 코드 평가 단계와 코드 실행 단계 2단계로 나누어 진행하고, 코드 평가 단계에서 실행콘텍스트가 생성됨.
> - 콜스택 : 실행컨텍스트를 쌓는 곳, 실행콘텍스트들은 각자 코드에 대한 환경만 다루고, 이 실행콘텍스트들이 모여 현재 환경이 됨. (예. 함수코드 실행시, 함수실행콘텍스트 뿐만 아니라, 전역실행콘텍스트의 내용을 참조함)

#### 실행컨텍스트와 콜스택이 나오게된 배경

js 실행시키는 js engine 입장에서는 아래 내용을 어떤식으로 처리하고 관리할지 생각해야함.

1. 스코프 관리 : 변수와 함수 스코프(생명 주기와 가시성)의 관리가 필요
2. this 바인딩 : this 가 어떤걸 가리킬지 관리가 필요
3. 코드 실행 관리 : js는 싱글 스레드 언어로 한 번에 하나의 작업만 처리함. 해당 스레드에서 현재 어떤 코드를 실행하고 있고, 어떤 함수를 먼저 처리할지에 대한 코드 실행 관리가 필요함
4. 기타 등등

- 위에 것들을 어떻게 처리할까라는 관점에서 실행컨텍스트와 콜스택이라는 개념을 도입함.
- 실행컨텍스트라는 개념을 사용하면 위 내용들을 명확하고, 빠르게 다룰 수 있음.

#### 실행컨텍스트란?

- 코드 실행에 필요한 환경을 담은 객체
  - 식별자 (변수명, 함수명) 또는 this에 따른 값이 무엇인가? 에 대한 내용
  - generator 함수의 현재 상태에 대한 내용등
- ES 버전에 따라 실행컨텍스트 구조가 조금씩 달라져왔음

#### 실행컨텍스트 생성

- js 엔진은 코드 실행시, 두 단계를 거쳐서 실행함
  - 1단계 : 코드 평가 단계
  - 2단계 : 코드 실행 단계
- 1단계 코드 평가 단계에서 해당 코드에 대한 실행콘텍스트를 생성하고,
- 2단계 코드 실행 단계에서 실행컨텍스트 안의 내용을 참조 혹은 업데이트 함.

#### 실행컨텍스트의 종류

- 실행 컨텍스트는 4가지 종류가 있음
- js 코드에는 4가지 종류의 코드가 있고, 이에 따라 실행 컨텍스트 종류가 정해짐
  - 전역코드 => 전역 실행 컨텍스트
  - 함수코드 => 함수 실행 컨텍스트
  - ~~eval코드 => eval 실행 컨텍스트~~
  - ~~모듈코드 => 모듈 실행 컨텍스트~~
- eval()은 Cross Site Script 공격에 사용될 수 있어, 굳이 살펴보지 말자!
- 모듈 코드는 일단 이해에 복잡성을 더하니, 제외

#### 실행컨텍스트와 콜스택

- 콜스택은 현재 실행 중인 실행컨텍스트들을 스택 형태로 관리하는 애임.
- 하나의 실행 콘텍스트는 딱 그 해당 코드에 대한 내용만 담고 있음. (예를 들어 함수실행컨텍스트의 경우, 전역변수등에 대한 내용을 모르는 상태임)
- 콜스택에 실행컨텍스트들이 쌓이고, 이 실행컨텍스트들의 집합으로서 실제 코드 실행에 필요한 전체 환경을 알 수 있게 됨. (예. 함수실행컨텍스트에서 전역변수의 내용을 참고)
- 콜스택의 최상위단의 실행콘텍스트는 현재 실행중인 코드에 대한 실행콘텍스트가 됨
- 가장 위에 있는 실행컨텍스트를 우선적으로 this가 무엇인지, 함수명에 따른 함수가 무엇인지, 변수명에 따른 변수가 무엇인지 확인하게되고, 확인할 수 없는 경우, 그 아래 실행컨텍스트로 내려가서 찾아보고, 또 확인 못하는 경우 그 아래로 내려가면서 찾아보는 로직임.

#### 실행컨텍스트 생성과 콜스택 과정

```
const x = 1;
funcion foo() {
	const y = 1;
}

foo();
```

- 가장 먼저 전역코드를 평가하고, 전역실행컨텍스트를 생성함.
  - 이때 전역실행컨텍스트에는 변수 x 선언과 foo함수의 선언 내용이 들어감
- 생성된 전역실행컨텍스트를 콜스택에 쌓음.
- 전역코드를 실행중, const x= 1;을 만나면, 전역실행컨텍스트 변수 x에 1을 넣어줌.
- 전역코드를 실행중, function foo() { const y = 1;}을 만나면 전역실행컨텍스트 foo에 `function object`를 넣어줌
- 다음 전역코드foo() 실행을 만나면, foo 함수코드를 평가하고, foo함수실행컨텍스트를 생성함.
  - 이때 foo함수실행컨텍스트에는 변수 y 선언이 들어감
- 생성된 foo함수실행컨텍스트를 콜스택에 쌓음.
- foo함수 코드를 실행하고 const y = 1;을 만나면, foo함수 실행컨텍스트 변수 y에 1을 넣어줌
- 실행이 완료되면 foo함수실행컨텍스트를 콜스택에서 제거
- 전역코드 실행이 완료되면 전역실행컨텍스트를 콜스택에서 제거

#### 실행컨텍스트의 실제 구현 내용

- 실행 컨텍스트 안에는 여러 내용이 들어가 있고, ECMA 버전에 따라 구조가 조금씩 달라짐
- ES6 기준 실행 컨텍스트 구조
  - Lexical Environment
    - Environment Records
      - Decalaritive Environment Records (선언적환경레코드) : 함수, 변수, this등 대부분의 내용이 여기에 저장됨. 변수나 함수이름을 직접 레코드 내에 저장함.
      - Object Environment Records (객체환경레코드) : 전역실행콘텍스트에서 사용됨, 전역객체(window)를 가리키고 있으며 window라는 식별자 없이 window객체 안에 property에 접근할 수 있도록 해줌. (with문 안에서 제공되는 객체를 바인딩할 때에도 사용된다고 함.)
      - Declarative Environment Records들은 변수나 함수명을 식별자로 하여 접근하는 반면,
    - Outer Reference Environment : 상위 실행콘텍스트가 무엇인지 가리키는 역할, 이참조를 통해, 실행컨텍스트를 타고 타고 올라가면서 검색할 수 있음. (체이닝), 전역 실행 컨텍스트는 최상위 실행컨텍스트이므로 전역 실행 컨텍스트의 Outer Reference Environment는 null임
  - Variable Environment (var에 대한 내용으로 let, const만 쓴다면 신경을 크게 쓰지 않아도 되는 부분)
    - var로 선언되는 애들을 따로 모으는 부분.
    - const, let과 var는 아래의 차이점을 가짐.
      - let, const는 블록{} 스코프(예. if, while 안쪽{})인 반면 var는 함수 스코프({}과 관계 없이 함수 전체에서 유효)를 사용함
      - 변수는 3단계(선언, 초기화, 할당 단계를 거치는데, var는 평가과정에서 2번까지 진행되어 undefined까지 실행이되지만, const, let은 선언까지만 진행되어 TDZ(TEmporal Dead Zone)을 지원하도록 설계됨.
    - var 환경을 따로 분리하지 않으면, 구조가 복잡(동일 실행컨텍스트 내에 중첩된 lexical environment를 만들어야함)해짐.

#### 추가 궁금한 점

- 왜 js는 싱글 스레드 방식을 선택했나?
  - 초기 자바스크립트는 주로 웹페이지의 DOM을 조작하는 역할을 했고, 멀티 스레드가 DOM을 조작하려고 하면 오류가 발생할 가능성이 높을 것을 대비하여.. 싱글스레드로 결정했다고 함.
  - 기본적으로 싱글 스레드이긴 하나, 비동기적으로 작업을 처리하여 멀티 스레드처럼 보이는 효과를 냄
- 실행컨텍스트가 실행되고, 콜스택에 쌓이는 과정이 OS에서 태스크를 관리하는 것과 비슷하게 보이는데, 그럼 프로그램 카운터 같은 개념도 포함되어있나?
  - 일단 gpt는 아니라고 함. 좀 더 높은 수준에서 프로그램의 실행 흐름을 제어하고 관리하기 위한 부분이라고 함.
- 왜 호이스팅을 지원했을까?
  - 초기에는 js는 지금처럼 크고 복잡한 프로그램을 짤거라고 예상을 하지 못함. 초기 목표는 개발자가 코드를 쉽게 작성하게 하는 것이었는데, 호이스팅을 지원하면 함수를 사용해 main 부분을 먼저 짜고, 추후에 함수의 구체적인 내용을 구현할 수 있기 때문에 코드 작성의 유연성을 줄 수 있었으나, 지금은 이런 부분 때문에 문제가 발생하기도 함. var대신 const, let을 사용하여 이를 해결하기도 함. (var은 평가 단계에서 undefined로 초기화 되지만, let과 const는 선언 전에 접근하려고 하면 Temporal Dead Zone에 의해 reference Error가 나도록 설계됨?)
- 왜 코드실행을 평가와 실행이라는 두 단계로 나누었을까?
  - 호이스팅 메커니즘 구현 가능, 코드 실행전 오류 확인, 스코프 및 환경설정
